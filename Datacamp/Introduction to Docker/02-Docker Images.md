# Docker Images

 Key Commands for Container Lifecycle:

*   **`docker run <image-name>`:** Starts a new container from the specified image.
    *   **Default Behavior:** By default, Docker runs the container and displays its output directly in your terminal. The container stops once its primary process finishes.
    *   **Example (`hello-world`):** `docker run hello-world` will print an introductory message and then stop, as designed by its creators.
    *   **Example (`ubuntu` without flags):** `docker run ubuntu` will start and immediately shut down because the `ubuntu` image's default `CMD` (which defines what runs when the container starts) is often set to something that exits quickly if not interactive.

*   **`docker run -it <image-name>` (Interactive Containers):** Use the `-it` flags to run a container in interactive mode and get a pseudo-TTY (terminal). This is essential for images designed for user interaction, like an operating system.
    *   **`-i`:** Keeps the standard input (stdin) open, even if not attached.
    *   **`-t`:** Allocates a pseudo-TTY, enabling an interactive shell.
    *   **Example:** `docker run -it ubuntu` will launch an Ubuntu container and provide you with a bash shell prompt inside it, allowing you to execute commands within the isolated Ubuntu environment.
    *   To exit the interactive session and stop the container, type `exit`.

*   **`docker run -d <image-name>` (Detached Containers):** Use the `-d` flag to run a container in "detached" mode, meaning it runs in the background. This is ideal for long-running services (e.g., databases, web servers) that don't need their output continuously displayed in your terminal.
    *   **Example:** `docker run -d postgres` will start a PostgreSQL database server in the background. Its output (logs) will not clutter your terminal.

*   **`docker ps`** or **`docker container ls`:** Lists all currently running containers. This command is crucial for monitoring your active Docker environment. It displays information such as `CONTAINER ID`, `IMAGE`, `COMMAND`, `CREATED`, `STATUS`, `PORTS`, and `NAMES`.

*   **`docker stop <container-id | container-name>`:** Stops a running container. You can use either the unique container ID (from `docker ps`) or a custom name you assigned to stop it.

**Code Snippets:**

```bash
docker run hello-world                     # Run a hello-world container (prints output, then stops)
docker run -it ubuntu                      # Run an Ubuntu container interactively, get a shell
docker run -d postgres                     # Run a PostgreSQL container in the background (detached)
docker ps                                  # Show currently running containers
docker stop <container-id_or_name>         # Stop a running container
```

### 2. Streamlining Container Workflow

Efficiently managing containers becomes vital when working with numerous instances.

#### Naming Containers:

*   **`docker run --name <custom-name> <image-name>`:** Assigns a human-readable name to a container at creation. This name simplifies identification in `docker ps` output and can be used in subsequent Docker commands instead of the generated `CONTAINER ID`.
    *   **Example:** `docker run -d --name db_pipeline_v1 postgres`

#### Filtering Containers:

*   **`docker ps -f "name=<container_name>"`:** Filters the output of `docker ps` to display only containers matching specific criteria.
    *   **`-f` (filter):** Specifies a filter.
    *   **Example:** `docker ps -f "name=db_pipeline_v1"` will show only the container named `db_pipeline_v1`. Filters can be applied to other properties too (e.g., `status=exited`).

#### Viewing Container Logs:

*   **`docker logs <container-id | container-name>`:** Retrieves and displays the historical logs generated by a container. Useful for debugging issues after a container has run.
*   **`docker logs -f <container-id | container-name>`:** "Follows" the logs, displaying new output in real-time as the container generates it. Press `Ctrl + C` to exit the live log view.

#### Removing Containers:

*   **`docker rm <container-id | container-name>`** or **`docker container rm <container-id | container-name>`:** Permanently removes a *stopped* container from your system, freeing up disk space and allowing its name to be reused.
*   **`docker container prune`:** A convenient command to remove all stopped (non-running) containers in one go, freeing up significant disk space.

**Code Snippets:**

```shell
docker run -d --name linux_sandbox ubuntu # Run a detached Ubuntu container and name it
docker ps -f "name=linux_sandbox"         # Filter running containers by name
docker logs linux_sandbox                 # Show the logs of the container
docker stop linux_sandbox                 # Stop the running container
docker rm linux_sandbox                   # Delete the stopped container
```

### 3. Sharing and Managing Docker Images

Images are fundamental to Docker. You'll typically get them from registries or create your own.

#### Docker Registries:

*   **Docker Hub:** The official and most popular public registry for Docker images. It hosts thousands of pre-built images.
*   **Private Registries:** Organizations or individuals can host their own registries for private image storage and distribution. Images from private registries are identifiable by a URL prefix (e.g., `dockerhub.myprivateregistry.com/image:version`).

#### Pulling Images from Registries:

*   **`docker pull <image-name>`:** Downloads an image from Docker Hub (or a configured default registry). By default, it pulls the `latest` tag.
*   **`docker pull <image-name>:<version_or_tag>`:** Downloads a specific version or tag of an image. Tags can be numerical (e.g., `22.04`) or descriptive (e.g., `jammy`).

#### Pushing Images to Registries:

*   **`docker push <registry-url/image-name:tag>`:** Uploads an image to a Docker registry.
*   **Renaming Images (`docker tag`):** Before pushing to a specific private registry, you might need to rename (tag) your local image to include the registry's URL prefix.
    *   **Example:** `docker tag classify_spam:v1 docker.myprivateregistry.com/classify_spam:v1`
    *   Then: `docker push docker.myprivateregistry.com/classify_spam:v1`

#### Authenticating with Private Registries:

*   **`docker login <registry-url>`:** Used to authenticate with private Docker registries that require credentials. The URL provided must match the prefix used for image names.
    *   **Example:** `docker login dockerhub.myprivateregistry.com`

#### Exporting/Importing Images as Files:

*   **`docker save -o <filename.tar> <image-name:tag>`:** Exports a Docker image (or multiple images) as a `.tar` archive file. This is useful for sharing images with a small group of people without a registry.
    *   **Example:** `docker save -o spam_updated.tar spam:v2`
*   **`docker load --input <filename.tar>`:** Imports Docker images from a `.tar` archive file into your local Docker image cache.
    *   **Example:** `docker load --input spam_bob.tar`

#### Managing Local Images:

*   **`docker images`** or **`docker image ls`:** Lists all images currently stored on your local machine, including their tags, size, and ID.
*   **`docker rmi <image-id | image-name:tag>`** or **`docker image rm <image-id | image-name:tag>`:** Removes an image from local storage.
    *   **Important:** An image can only be deleted if no containers are based on it. If containers exist, you'll receive an error and must remove the associated containers first.
*   **`docker image prune`:** Removes "dangling" images. A dangling image is one that no longer has a name/tag because it was superseded (e.g., when rebuilding an image with the same name).
*   **`docker image prune -a`:** Removes *all* unused images, including dangling images and any other images not associated with a running container.

**Code Snippets:**

```shell
docker tag classify_spam:v1 docker.myprivateregistry.com/classify_spam:v1 # Tag local image for a remote repo
docker push docker.mycompany.com/spam_alice:v3 # Upload image to a remote repo (after tagging)
docker login docker.mycompany.com # Log in to a private registry
docker pull docker.mycompany.com/spam_alice:v3 # Pull image from a private repo

docker save -o spam_updated.tar spam:v2 # Export Docker image as a .tar archive
docker load --input spam_bob.tar # Load image from a .tar archive

docker pull hello-world # Download latest hello-world image
docker images # List local images
docker image rm hello-world # Delete a local image (if no containers are based on it)
docker container prune # Remove all stopped containers
docker image prune -a # Remove all unused images
```

### 4. Creating Custom Docker Images with Dockerfiles

**Dockerfiles** are text files that contain a series of instructions for building a Docker image. They act as the "recipe" or "blueprint" for your custom container environments. Docker executes instructions in a Dockerfile from top to bottom. By convention, the file should be named `Dockerfile`.

#### Basic Dockerfile Structure and Instructions:

*   **`FROM <base-image>:<tag>`:** The **first instruction** in every Dockerfile. It specifies the base image upon which your custom image will be built. You can use any existing image (e.g., `ubuntu`, `python:3.9-slim`, `postgres`).
    *   **Example:** `FROM ubuntu` or `FROM python:3.9-slim`
*   **Building an Image:**
    *   **`docker build <path-to-dockerfile-context>`:** Builds an image from a Dockerfile.
    *   The `.` (dot) often represents the current working directory, indicating that the Dockerfile is in the current folder.
    *   **Output:** The build process generates a unique `sha256` hash (Image ID) for the new image.
*   **`docker build -t <image-name>:<tag> <path-to-dockerfile-context>`:** Assigns a recognizable name and optional version (tag) to the newly built image.
    *   **Example:** `docker build -t my-python-app:v1 .`

#### Customizing Images with `RUN` Instruction:

*   **`RUN <shell-command>`:** Executes any valid shell command *during the image build process*. This is how you install software, update packages, or configure the environment inside your image.
    *   **Example:** To install Python on an Ubuntu base image:
        ```dockerfile
        FROM ubuntu
        RUN apt-get update           # Update package list (important before installing)
        RUN apt-get install -y python3 # Install Python 3. The -y flag confirms installation without user input.
        ```
    *   **Build Time:** `RUN` instructions extend the build time as Docker executes the specified commands.

#### Best Practices for `RUN` (Chaining Commands):

To keep images small, perform file downloads, unzips, and removals in a single `RUN` instruction. Intermediate files (like `.zip` archives) would otherwise be saved as layers in the image history, increasing its size even if removed in a later step.

*   **Chaining Commands:** Use `\` for line breaks (readability) and `&&` to execute commands sequentially.
    ```dockerfile
    FROM ubuntu
    RUN apt-get update && \
        apt-get install -y python3 && \
        curl -o file.zip <URL_TO_FILE> && \
        unzip file.zip && \
        rm file.zip
    ```
    This ensures that temporary files are deleted within the *same layer*, minimizing the final image size.

#### Adding Files with `COPY` Instruction:

*   **`COPY <source-path-on-host> <destination-path-in-container>`:** Copies files or directories from your local host machine (where `docker build` is run) into the Docker image.
    *   **Source Path:** Can be a file or a folder. If a folder, its entire contents (including sub-folders) are copied.
    *   **Destination Path:** If it ends with a `/`, the source will be copied into that directory; otherwise, if it's a filename, the source will be renamed to that filename.
    *   **Example:** `COPY ./pipeline.py /app/pipeline.py` (copies `pipeline.py` from current host directory to `/app/pipeline.py` in container).
    *   **Important:** You cannot copy files from a parent directory of the Dockerfile's context (the directory where `docker build` is executed).

*   **`ADD` Instruction:** While `ADD` can also copy files and handle archives automatically, `COPY` combined with `RUN` for specific download/unzip/cleanup tasks is generally preferred for clarity and image size control.

**Code Snippets:**

```bash
# Create a Dockerfile
touch Dockerfile
nano Dockerfile # or use any text editor

# Example Dockerfile content:
# FROM ubuntu
# RUN apt-get update
# RUN apt-get install -y python3
# COPY ./app_code /app
# WORKDIR /app
# CMD ["python3", "main.py"]

# Build the Dockerfile and name it python_image
docker build -t python_image .

# Copy a specific file
COPY ./pipeline.py ./app/pipeline.py

# Copy an entire folder
COPY ./app_code /app/
```

### 5. Setting Default Commands with `CMD`

The `CMD` instruction defines the default command that will be executed when a container is started from your image.

*   **`CMD ["executable", "param1", "param2"]` (Exec Form - Preferred):** Specifies the command as an array, where the first element is the executable and subsequent elements are arguments.
*   **`CMD command param1 param2` (Shell Form):** Executes the command directly in a shell.
*   **Behavior:** The `CMD` instruction is *not* executed during `docker build`. It only runs when `docker run` is called without specifying an overriding command.
*   **Image Size/Build Time:** `CMD` does not increase image size or build time.
*   **Multiple `CMD` Instructions:** Only the *last* `CMD` instruction in a Dockerfile will take effect.
*   **Purpose:** For specific-use images, `CMD` should start the core application (e.g., a Python script, a database server). For general-purpose images (like an Ubuntu base image), `CMD` might open a shell (e.g., `CMD ["bash"]`). The container stops when the `CMD` process exits.

#### Overriding `CMD` at Runtime:

*   **`docker run <image-name> <new-command>`:** You can override the `CMD` instruction defined in the Dockerfile by providing a command as a second argument to `docker run`.
    *   **Example:** If an image has `CMD ["python3", "app.py"]`, `docker run my-app-image bash` would override it and start a bash shell instead.
    *   Often, when overriding, you'll use `-it` to interact with the new command (e.g., `docker run -it my-ubuntu-image bash`).

**Code Snippet (Dockerfile):**

```dockerfile
# Inside a Dockerfile
CMD ["python3"] # Sets python3 as the default command when container starts
```